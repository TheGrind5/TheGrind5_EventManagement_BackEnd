# View Event Detail - Database Queries

## 1. GetEventById
LINQ Query (C#):
return await _context.Events
    .Include(e => e.Host)
    .Include(e => e.TicketTypes)
    .FirstOrDefaultAsync(e => e.EventId == eventId);

SQL Query (Generated by EF Core):
SELECT [e].[EventId], [e].[HostId], [e].[Title], [e].[Description], 
       [e].[StartTime], [e].[EndTime], [e].[Location], [e].[Category], 
       [e].[Status], [e].[CreatedAt], [e].[UpdatedAt],
       [u].[UserID], [u].[Username], [u].[FullName], [u].[Email],
       [t].[TicketTypeId], [t].[EventId], [t].[TypeName], [t].[Price], 
       [t].[Quantity], [t].[MinOrder], [t].[MaxOrder], [t].[SaleStart], 
       [t].[SaleEnd], [t].[Status]
FROM [Event] AS [e]
LEFT JOIN [User] AS [u] ON [e].[HostId] = [u].[UserID]
LEFT JOIN [TicketType] AS [t] ON [e].[EventId] = [t].[EventId]
WHERE [e].[EventId] = @eventId

## 2. GetEventById (Alternative with WHERE clause)
LINQ Query (C#):
return await _context.Events
    .Include(e => e.Host)
    .Include(e => e.TicketTypes)
    .Where(e => e.EventId == eventId)
    .FirstOrDefaultAsync();

SQL Query (Generated by EF Core):
SELECT [e].[EventId], [e].[HostId], [e].[Title], [e].[Description], 
       [e].[StartTime], [e].[EndTime], [e].[Location], [e].[Category], 
       [e].[Status], [e].[CreatedAt], [e].[UpdatedAt],
       [u].[UserID], [u].[Username], [u].[FullName], [u].[Email],
       [t].[TicketTypeId], [t].[EventId], [t].[TypeName], [t].[Price], 
       [t].[Quantity], [t].[MinOrder], [t].[MaxOrder], [t].[SaleStart], 
       [t].[SaleEnd], [t].[Status]
FROM [Event] AS [e]
LEFT JOIN [User] AS [u] ON [e].[HostId] = [u].[UserID]
LEFT JOIN [TicketType] AS [t] ON [e].[EventId] = [t].[EventId]
WHERE [e].[EventId] = @eventId

## 3. GetEventById (With Status Filter)
LINQ Query (C#):
return await _context.Events
    .Include(e => e.Host)
    .Include(e => e.TicketTypes)
    .Where(e => e.EventId == eventId && e.Status == "Open")
    .FirstOrDefaultAsync();

SQL Query (Generated by EF Core):
SELECT [e].[EventId], [e].[HostId], [e].[Title], [e].[Description], 
       [e].[StartTime], [e].[EndTime], [e].[Location], [e].[Category], 
       [e].[Status], [e].[CreatedAt], [e].[UpdatedAt],
       [u].[UserID], [u].[Username], [u].[FullName], [u].[Email],
       [t].[TicketTypeId], [t].[EventId], [t].[TypeName], [t].[Price], 
       [t].[Quantity], [t].[MinOrder], [t].[MaxOrder], [t].[SaleStart], 
       [t].[SaleEnd], [t].[Status]
FROM [Event] AS [e]
LEFT JOIN [User] AS [u] ON [e].[HostId] = [u].[UserID]
LEFT JOIN [TicketType] AS [t] ON [e].[EventId] = [t].[EventId]
WHERE [e].[EventId] = @eventId AND [e].[Status] = N'Open'

## Key Differences from GetAllEvents:

1. **Single Event**: Uses `FirstOrDefaultAsync()` instead of `ToListAsync()`
2. **Specific ID**: Filters by `EventId = @eventId` instead of `Status = 'Open'`
3. **No Ordering**: No `OrderBy()` clause needed for single record
4. **Same Includes**: Still includes Host and TicketTypes for complete data
5. **Same JOINs**: Uses LEFT JOIN to get related data

## Performance Considerations:

- **Index on EventId**: Primary key lookup is very fast
- **Include Performance**: May cause N+1 query issues with large TicketTypes
- **Single Record**: Much faster than GetAllEvents query
- **Caching**: Single event can be easily cached by ID

## Usage in Code:

```csharp
// EventRepository.cs
public async Task<Event?> GetEventByIdAsync(int eventId)
{
    return await _context.Events
        .Include(e => e.Host)
        .Include(e => e.TicketTypes)
        .FirstOrDefaultAsync(e => e.EventId == eventId);
}
```

## Response Data Structure:

The query returns a single Event entity with:
- **Event properties**: EventId, Title, Description, StartTime, EndTime, Location, Category, Status, CreatedAt, UpdatedAt
- **Host information**: UserID, Username, FullName, Email (from User table)
- **TicketTypes**: Array of ticket type objects with all properties
- **Null handling**: Uses LEFT JOIN so missing Host or TicketTypes won't break the query
