# Database Queries - Payment Flow

## 1. Wallet Balance Retrieval
**LINQ Query (C#):**
```csharp
var user = await _userRepository.GetUserByIdAsync(userId);
return user?.WalletBalance ?? 0;
```

**SQL Query (Generated by EF Core):**
```sql
SELECT TOP(1)
    [u].[UserId], [u].[Username], [u].[FullName], [u].[Email],
    [u].[PasswordHash], [u].[Phone], [u].[Role], [u].[CreatedAt],
    [u].[UpdatedAt], [u].[Avatar], [u].[DateOfBirth], [u].[Gender],
    [u].[WalletBalance]
FROM [Users] AS [u]
WHERE [u].[UserId] = @__userId_0
```

## 2. Sufficient Balance Validation
**LINQ Query (C#):**
```csharp
var balance = await GetWalletBalanceAsync(userId);
return balance >= amount;
```

**SQL Query (Generated by EF Core):**
```sql
SELECT TOP(1)
    [u].[WalletBalance]
FROM [Users] AS [u]
WHERE [u].[UserId] = @__userId_0
```

## 3. Order Retrieval for Payment
**LINQ Query (C#):**
```csharp
return await _context.Orders
    .Include(o => o.Customer)
    .Include(o => o.OrderItems)
    .FirstOrDefaultAsync(o => o.OrderId == orderId);
```

**SQL Query (Generated by EF Core):**
```sql
SELECT [o].[OrderId], [o].[CustomerId], [o].[Amount], [o].[Status], 
       [o].[PaymentMethod], [o].[CreatedAt], [o].[UpdatedAt],
       [c].[UserId], [c].[Username], [c].[FullName], [c].[Email],
       [c].[PasswordHash], [c].[Phone], [c].[Role], [c].[CreatedAt],
       [c].[UpdatedAt], [c].[Avatar], [c].[DateOfBirth], [c].[Gender],
       [c].[WalletBalance]
FROM [Orders] AS [o]
LEFT JOIN [Users] AS [c] ON [o].[CustomerId] = [c].[UserId]
WHERE [o].[OrderId] = @__orderId_0
```

## 4. Wallet Transaction Creation (Payment)
**LINQ Query (C#):**
```csharp
var walletTransaction = new WalletTransaction
{
    UserId = userId,
    Amount = amount,
    TransactionType = "Payment",
    Status = "Completed",
    Description = description ?? $"Payment for order #{orderId}",
    ReferenceId = orderId.ToString(),
    CreatedAt = DateTime.UtcNow,
    CompletedAt = DateTime.UtcNow,
    BalanceBefore = balanceBefore,
    BalanceAfter = balanceAfter
};

_context.WalletTransactions.Add(walletTransaction);
await _context.SaveChangesAsync();
```

**SQL Query (Generated by EF Core):**
```sql
INSERT INTO [WalletTransactions] (
    [UserId], [Amount], [TransactionType], [Status], [Description],
    [ReferenceId], [CreatedAt], [CompletedAt], [BalanceBefore], [BalanceAfter]
)
VALUES (
    @userId, @amount, @transactionType, @status, @description,
    @referenceId, @createdAt, @completedAt, @balanceBefore, @balanceAfter
);
SELECT [TransactionId] FROM [WalletTransactions] WHERE @@ROWCOUNT = 1 AND [TransactionId] = scope_identity();
```

## 5. User Wallet Balance Update (Payment)
**LINQ Query (C#):**
```csharp
user.WalletBalance = balanceAfter;
user.UpdatedAt = DateTime.UtcNow;
await _userRepository.UpdateUserAsync(user);
```

**SQL Query (Generated by EF Core):**
```sql
UPDATE [Users] 
SET [WalletBalance] = @balanceAfter, [UpdatedAt] = @updatedAt
WHERE [UserId] = @userId;
SELECT @@ROWCOUNT;
```

## 6. Order Status Update (After Payment)
**LINQ Query (C#):**
```csharp
var order = await _context.Orders.FindAsync(orderId);
if (order != null)
{
    order.Status = "Paid";
    order.UpdatedAt = DateTime.UtcNow;
    await _context.SaveChangesAsync();
}
```

**SQL Query (Generated by EF Core):**
```sql
UPDATE [Orders] 
SET [Status] = @status, [UpdatedAt] = @updatedAt
WHERE [OrderId] = @orderId;
SELECT @@ROWCOUNT;
```

## 7. Wallet Deposit Transaction Creation
**LINQ Query (C#):**
```csharp
var walletTransaction = new WalletTransaction
{
    UserId = userId,
    Amount = amount,
    TransactionType = "Deposit",
    Status = "Completed",
    Description = description ?? "Wallet deposit",
    ReferenceId = referenceId,
    CreatedAt = DateTime.UtcNow,
    CompletedAt = DateTime.UtcNow,
    BalanceBefore = balanceBefore,
    BalanceAfter = balanceAfter
};

_context.WalletTransactions.Add(walletTransaction);
await _context.SaveChangesAsync();
```

**SQL Query (Generated by EF Core):**
```sql
INSERT INTO [WalletTransactions] (
    [UserId], [Amount], [TransactionType], [Status], [Description],
    [ReferenceId], [CreatedAt], [CompletedAt], [BalanceBefore], [BalanceAfter]
)
VALUES (
    @userId, @amount, @transactionType, @status, @description,
    @referenceId, @createdAt, @completedAt, @balanceBefore, @balanceAfter
);
SELECT [TransactionId] FROM [WalletTransactions] WHERE @@ROWCOUNT = 1 AND [TransactionId] = scope_identity();
```

## 8. Wallet Withdrawal Transaction Creation
**LINQ Query (C#):**
```csharp
var walletTransaction = new WalletTransaction
{
    UserId = userId,
    Amount = amount,
    TransactionType = "Withdraw",
    Status = "Completed",
    Description = description ?? "Wallet withdrawal",
    ReferenceId = referenceId,
    CreatedAt = DateTime.UtcNow,
    CompletedAt = DateTime.UtcNow,
    BalanceBefore = balanceBefore,
    BalanceAfter = balanceAfter
};

_context.WalletTransactions.Add(walletTransaction);
await _context.SaveChangesAsync();
```

**SQL Query (Generated by EF Core):**
```sql
INSERT INTO [WalletTransactions] (
    [UserId], [Amount], [TransactionType], [Status], [Description],
    [ReferenceId], [CreatedAt], [CompletedAt], [BalanceBefore], [BalanceAfter]
)
VALUES (
    @userId, @amount, @transactionType, @status, @description,
    @referenceId, @createdAt, @completedAt, @balanceBefore, @balanceAfter
);
SELECT [TransactionId] FROM [WalletTransactions] WHERE @@ROWCOUNT = 1 AND [TransactionId] = scope_identity();
```

## 9. Refund Transaction Creation
**LINQ Query (C#):**
```csharp
var walletTransaction = new WalletTransaction
{
    UserId = userId,
    Amount = amount,
    TransactionType = "Refund",
    Status = "Completed",
    Description = description ?? $"Refund for order #{orderId}",
    ReferenceId = orderId.ToString(),
    CreatedAt = DateTime.UtcNow,
    CompletedAt = DateTime.UtcNow,
    BalanceBefore = balanceBefore,
    BalanceAfter = balanceAfter
};

_context.WalletTransactions.Add(walletTransaction);
await _context.SaveChangesAsync();
```

**SQL Query (Generated by EF Core):**
```sql
INSERT INTO [WalletTransactions] (
    [UserId], [Amount], [TransactionType], [Status], [Description],
    [ReferenceId], [CreatedAt], [CompletedAt], [BalanceBefore], [BalanceAfter]
)
VALUES (
    @userId, @amount, @transactionType, @status, @description,
    @referenceId, @createdAt, @completedAt, @balanceBefore, @balanceAfter
);
SELECT [TransactionId] FROM [WalletTransactions] WHERE @@ROWCOUNT = 1 AND [TransactionId] = scope_identity();
```

## 10. User Transaction History Retrieval
**LINQ Query (C#):**
```csharp
return await _context.WalletTransactions
    .Where(wt => wt.UserId == userId)
    .OrderByDescending(wt => wt.CreatedAt)
    .Skip((page - 1) * pageSize)
    .Take(pageSize)
    .ToListAsync();
```

**SQL Query (Generated by EF Core):**
```sql
SELECT [w].[TransactionId], [w].[UserId], [w].[Amount], [w].[TransactionType],
       [w].[Status], [w].[Description], [w].[ReferenceId], [w].[CreatedAt],
       [w].[CompletedAt], [w].[BalanceBefore], [w].[BalanceAfter]
FROM [WalletTransactions] AS [w]
WHERE [w].[UserId] = @__userId_0
ORDER BY [w].[CreatedAt] DESC
OFFSET @__p_0 ROWS FETCH NEXT @__p_1 ROWS ONLY
```

## 11. Transaction Retrieval by ID
**LINQ Query (C#):**
```csharp
return await _context.WalletTransactions
    .Include(wt => wt.User)
    .FirstOrDefaultAsync(wt => wt.TransactionId == transactionId);
```

**SQL Query (Generated by EF Core):**
```sql
SELECT [w].[TransactionId], [w].[UserId], [w].[Amount], [w].[TransactionType],
       [w].[Status], [w].[Description], [w].[ReferenceId], [w].[CreatedAt],
       [w].[CompletedAt], [w].[BalanceBefore], [w].[BalanceAfter],
       [u].[UserId], [u].[Username], [u].[FullName], [u].[Email],
       [u].[PasswordHash], [u].[Phone], [u].[Role], [u].[CreatedAt],
       [u].[UpdatedAt], [u].[Avatar], [u].[DateOfBirth], [u].[Gender],
       [u].[WalletBalance]
FROM [WalletTransactions] AS [w]
LEFT JOIN [Users] AS [u] ON [w].[UserId] = [u].[UserId]
WHERE [w].[TransactionId] = @__transactionId_0
```

## 12. Payment Entity Creation (Optional - for audit trail)
**LINQ Query (C#):**
```csharp
var payment = new Payment
{
    OrderId = orderId,
    Amount = amount,
    Method = "Wallet",
    Status = "Succeeded",
    PaymentDate = DateTime.UtcNow
};

_context.Payments.Add(payment);
await _context.SaveChangesAsync();
```

**SQL Query (Generated by EF Core):**
```sql
INSERT INTO [Payments] (
    [OrderId], [Amount], [Method], [Status], [PaymentDate]
)
VALUES (
    @orderId, @amount, @method, @status, @paymentDate
);
SELECT [PaymentId] FROM [Payments] WHERE @@ROWCOUNT = 1 AND [PaymentId] = scope_identity();
```

## 13. Database Transaction Management
**LINQ Query (C#):**
```csharp
using var transaction = await _context.Database.BeginTransactionAsync();
try
{
    // Multiple operations here
    await _context.SaveChangesAsync();
    await transaction.CommitAsync();
}
catch
{
    await transaction.RollbackAsync();
    throw;
}
```

**SQL Query (Generated by EF Core):**
```sql
BEGIN TRANSACTION;
-- Multiple SQL operations here
COMMIT TRANSACTION;
-- OR
ROLLBACK TRANSACTION;
```

## 14. Wallet Balance Validation for Withdrawal
**LINQ Query (C#):**
```csharp
var user = await _userRepository.GetUserByIdAsync(userId);
if (user == null) return false;
return user.WalletBalance >= amount;
```

**SQL Query (Generated by EF Core):**
```sql
SELECT TOP(1)
    [u].[WalletBalance]
FROM [Users] AS [u]
WHERE [u].[UserId] = @__userId_0
```

## 15. Order Payment Status Check
**LINQ Query (C#):**
```csharp
return await _context.Orders
    .Where(o => o.OrderId == orderId && o.Status == "Pending")
    .AnyAsync();
```

**SQL Query (Generated by EF Core):**
```sql
SELECT COUNT(*)
FROM [Orders] AS [o]
WHERE ([o].[OrderId] = @__orderId_0) AND ([o].[Status] = @__status_1)
```

## Key Database Operations Summary:

1. **Wallet Balance Operations**: SELECT, UPDATE User.WalletBalance
2. **Transaction Tracking**: INSERT WalletTransaction records
3. **Order Status Updates**: UPDATE Order.Status
4. **Payment Audit**: INSERT Payment records (optional)
5. **Transaction History**: SELECT WalletTransaction with pagination
6. **Validation Queries**: SELECT for balance/status checks
7. **Atomic Transactions**: BEGIN/COMMIT/ROLLBACK for data consistency

## Performance Considerations:

- **Indexes**: UserId, TransactionId, CreatedAt, OrderId
- **Pagination**: Skip/Take for transaction history
- **Transaction Isolation**: Serializable for financial operations
- **Connection Pooling**: Reuse database connections
- **Query Optimization**: Include() for related entities
