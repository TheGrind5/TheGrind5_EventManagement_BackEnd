# Database Queries cho Luồng BuyTicket (Mua Vé Sự Kiện)
# Dựa trên phân tích code trong dự án TheGrind5_EventManagement_BackEnd

## 1. VALIDATION PHASE - Kiểm tra dữ liệu đầu vào

### 1.1 ValidateUserExistsAsync
**LINQ Query (C#):**
```csharp
var user = await _context.Users.FindAsync(userId);
return user != null;
```

**SQL Query (Generated by EF Core):**
```sql
SELECT [u].[UserId], [u].[Username], [u].[FullName], [u].[Email], 
       [u].[PasswordHash], [u].[Phone], [u].[Role], [u].[WalletBalance], 
       [u].[CreatedAt], [u].[UpdatedAt], [u].[Avatar], [u].[DateOfBirth], [u].[Gender]
FROM [Users] AS [u]
WHERE [u].[UserId] = @userId
```

### 1.2 GetTicketTypeWithEventAsync
**LINQ Query (C#):**
```csharp
var ticketType = await _context.TicketTypes
    .Include(tt => tt.Event)
    .FirstOrDefaultAsync(tt => tt.TicketTypeId == request.TicketTypeId);
```

**SQL Query (Generated by EF Core):**
```sql
SELECT [t].[TicketTypeId], [t].[EventId], [t].[TypeName], [t].[Price], 
       [t].[Quantity], [t].[MinOrder], [t].[MaxOrder], [t].[SaleStart], 
       [t].[SaleEnd], [t].[Status],
       [e].[EventId], [e].[HostId], [e].[Title], [e].[Description], 
       [e].[StartTime], [e].[EndTime], [e].[Location], [e].[Category], 
       [e].[Status] AS [EventStatus], [e].[CreatedAt], [e].[UpdatedAt]
FROM [TicketTypes] AS [t]
INNER JOIN [Events] AS [e] ON [t].[EventId] = [e].[EventId]
WHERE [t].[TicketTypeId] = @ticketTypeId
```

### 1.3 GetAvailableQuantityAsync
**LINQ Query (C#):**
```csharp
var ticketType = await _context.TicketTypes
    .FirstOrDefaultAsync(tt => tt.TicketTypeId == ticketTypeId);

var usedQuantity = await _context.OrderItems
    .Where(oi => oi.TicketTypeId == ticketTypeId)
    .Where(oi => oi.Order.Status == "Paid" || oi.Order.Status == "Pending")
    .SumAsync(oi => oi.Quantity);

var availableQuantity = ticketType.Quantity - usedQuantity;
return Math.Max(0, availableQuantity);
```

**SQL Query (Generated by EF Core):**
```sql
-- Query 1: Get ticket type quantity
SELECT [t].[Quantity]
FROM [TicketTypes] AS [t]
WHERE [t].[TicketTypeId] = @ticketTypeId

-- Query 2: Get used quantity
SELECT COALESCE(SUM([o].[Quantity]), 0)
FROM [OrderItems] AS [o]
INNER JOIN [Orders] AS [o0] ON [o].[OrderId] = [o0].[OrderId]
WHERE ([o].[TicketTypeId] = @ticketTypeId) 
AND ([o0].[Status] = N'Paid' OR [o0].[Status] = N'Pending')
```

## 2. CREATE ORDER PHASE - Tạo đơn hàng

### 2.1 CreateOrderAsync
**LINQ Query (C#):**
```csharp
order.CreatedAt = DateTime.UtcNow;
order.Status = "Pending";

_context.Orders.Add(order);
await _context.SaveChangesAsync();

// Load related data
await _context.Entry(order)
    .Reference(o => o.Customer)
    .LoadAsync();
    
await _context.Entry(order)
    .Collection(o => o.OrderItems)
    .LoadAsync();
```

**SQL Query (Generated by EF Core):**
```sql
-- Insert Order
INSERT INTO [Orders] ([CustomerId], [Amount], [Status], [PaymentMethod], [CreatedAt])
VALUES (@customerId, @amount, N'Pending', NULL, @createdAt);

-- Get OrderId
SELECT SCOPE_IDENTITY() as [OrderId];

-- Load Customer
SELECT [u].[UserId], [u].[Username], [u].[FullName], [u].[Email], 
       [u].[PasswordHash], [u].[Phone], [u].[Role], [u].[WalletBalance], 
       [u].[CreatedAt], [u].[UpdatedAt], [u].[Avatar], [u].[DateOfBirth], [u].[Gender]
FROM [Users] AS [u]
WHERE [u].[UserId] = @customerId

-- Load OrderItems
SELECT [o].[OrderItemId], [o].[OrderId], [o].[TicketTypeId], [o].[Quantity], 
       [o].[SeatNo], [o].[Status]
FROM [OrderItems] AS [o]
WHERE [o].[OrderId] = @orderId
```

### 2.2 MapFromCreateOrderRequest
**LINQ Query (C#):**
```csharp
var order = new Order
{
    CustomerId = customerId,
    Amount = 0, // Will be set later
    Status = "Pending",
    PaymentMethod = null,
    CreatedAt = DateTime.UtcNow,
    OrderItems = new List<OrderItem>
    {
        new OrderItem
        {
            TicketTypeId = request.TicketTypeId,
            Quantity = request.Quantity,
            SeatNo = request.SeatNo,
            Status = "Reserved"
        }
    }
};
```

**SQL Query (Generated by EF Core):**
```sql
-- Insert OrderItem
INSERT INTO [OrderItems] ([OrderId], [TicketTypeId], [Quantity], [SeatNo], [Status])
VALUES (@orderId, @ticketTypeId, @quantity, @seatNo, N'Reserved');
```

### 2.3 GetOrderByIdAsync
**LINQ Query (C#):**
```csharp
return await _context.Orders
    .Include(o => o.Customer)
    .Include(o => o.OrderItems)
        .ThenInclude(oi => oi.TicketType)
            .ThenInclude(tt => tt.Event)
    .FirstOrDefaultAsync(o => o.OrderId == orderId);
```

**SQL Query (Generated by EF Core):**
```sql
SELECT [o].[OrderId], [o].[CustomerId], [o].[Amount], [o].[Status], 
       [o].[PaymentMethod], [o].[CreatedAt], [o].[UpdatedAt],
       [u].[UserId], [u].[Username], [u].[FullName], [u].[Email], 
       [u].[PasswordHash], [u].[Phone], [u].[Role], [u].[WalletBalance], 
       [u].[CreatedAt], [u].[UpdatedAt], [u].[Avatar], [u].[DateOfBirth], [u].[Gender],
       [o0].[OrderItemId], [o0].[OrderId], [o0].[TicketTypeId], [o0].[Quantity], 
       [o0].[SeatNo], [o0].[Status],
       [t].[TicketTypeId], [t].[EventId], [t].[TypeName], [t].[Price], 
       [t].[Quantity], [t].[MinOrder], [t].[MaxOrder], [t].[SaleStart], 
       [t].[SaleEnd], [t].[Status],
       [e].[EventId], [e].[HostId], [e].[Title], [e].[Description], 
       [e].[StartTime], [e].[EndTime], [e].[Location], [e].[Category], 
       [e].[Status] AS [EventStatus], [e].[CreatedAt], [e].[UpdatedAt]
FROM [Orders] AS [o]
INNER JOIN [Users] AS [u] ON [o].[CustomerId] = [u].[UserId]
LEFT JOIN [OrderItems] AS [o0] ON [o].[OrderId] = [o0].[OrderId]
LEFT JOIN [TicketTypes] AS [t] ON [o0].[TicketTypeId] = [t].[TicketTypeId]
LEFT JOIN [Events] AS [e] ON [t].[EventId] = [e].[EventId]
WHERE [o].[OrderId] = @orderId
```

## 3. PAYMENT PHASE - Xử lý thanh toán

### 3.1 HasSufficientBalanceAsync
**LINQ Query (C#):**
```csharp
var balance = await GetWalletBalanceAsync(userId);
return balance >= amount;
```

**SQL Query (Generated by EF Core):**
```sql
SELECT [u].[WalletBalance]
FROM [Users] AS [u]
WHERE [u].[UserId] = @userId
```

### 3.2 ProcessPaymentAsync
**LINQ Query (C#):**
```csharp
var user = await _userRepository.GetUserByIdAsync(userId);
var balanceBefore = user.WalletBalance;
var balanceAfter = balanceBefore - amount;

user.WalletBalance = balanceAfter;
user.UpdatedAt = DateTime.UtcNow;
await _userRepository.UpdateUserAsync(user);

var walletTransaction = new WalletTransaction
{
    UserId = userId,
    Amount = amount,
    TransactionType = "Payment",
    Status = "Completed",
    Description = description ?? $"Payment for order #{orderId}",
    ReferenceId = orderId.ToString(),
    CreatedAt = DateTime.UtcNow,
    CompletedAt = DateTime.UtcNow,
    BalanceBefore = balanceBefore,
    BalanceAfter = balanceAfter
};

_context.WalletTransactions.Add(walletTransaction);
await _context.SaveChangesAsync();
```

**SQL Query (Generated by EF Core):**
```sql
-- Update User Wallet Balance
UPDATE [Users] 
SET [WalletBalance] = @balanceAfter, [UpdatedAt] = @updatedAt
WHERE [UserId] = @userId

-- Insert Wallet Transaction
INSERT INTO [WalletTransactions] ([UserId], [TransactionType], [Amount], [Status], 
                                  [Description], [ReferenceId], [BalanceBefore], 
                                  [BalanceAfter], [CreatedAt], [CompletedAt])
VALUES (@userId, N'Payment', @amount, N'Completed', @description, 
        @referenceId, @balanceBefore, @balanceAfter, @createdAt, @completedAt)
```

### 3.3 UpdateOrderStatusAsync
**LINQ Query (C#):**
```csharp
var order = await _context.Orders.FindAsync(orderId);
if (order == null) return false;

order.Status = status;
order.UpdatedAt = DateTime.UtcNow;
await _context.SaveChangesAsync();
```

**SQL Query (Generated by EF Core):**
```sql
UPDATE [Orders] 
SET [Status] = @status, [UpdatedAt] = @updatedAt
WHERE [OrderId] = @orderId
```

## 4. TICKET CREATION PHASE - Tạo vé

### 4.1 CreateTicketsForOrderAsync
**LINQ Query (C#):**
```csharp
var order = await _context.Orders
    .Include(o => o.OrderItems)
        .ThenInclude(oi => oi.TicketType)
    .FirstOrDefaultAsync(o => o.OrderId == orderId);

foreach (var orderItem in order.OrderItems)
{
    await _ticketService.CreateTicketsForOrderItemAsync(
        orderItem.OrderItemId, 
        orderItem.Quantity, 
        orderItem.TicketTypeId
    );
}
```

**SQL Query (Generated by EF Core):**
```sql
-- Get Order with OrderItems
SELECT [o].[OrderId], [o].[CustomerId], [o].[Amount], [o].[Status], 
       [o].[PaymentMethod], [o].[CreatedAt], [o].[UpdatedAt],
       [o0].[OrderItemId], [o0].[OrderId], [o0].[TicketTypeId], [o0].[Quantity], 
       [o0].[SeatNo], [o0].[Status],
       [t].[TicketTypeId], [t].[EventId], [t].[TypeName], [t].[Price], 
       [t].[Quantity], [t].[MinOrder], [t].[MaxOrder], [t].[SaleStart], 
       [t].[SaleEnd], [t].[Status]
FROM [Orders] AS [o]
LEFT JOIN [OrderItems] AS [o0] ON [o].[OrderId] = [o0].[OrderId]
LEFT JOIN [TicketTypes] AS [t] ON [o0].[TicketTypeId] = [t].[TicketTypeId]
WHERE [o].[OrderId] = @orderId
```

### 4.2 CreateTicketsForOrderItemAsync
**LINQ Query (C#):**
```csharp
var orderItem = await _context.OrderItems
    .Include(oi => oi.Order)
    .Include(oi => oi.TicketType)
        .ThenInclude(tt => tt.Event)
    .FirstOrDefaultAsync(oi => oi.OrderItemId == orderItemId);

for (int i = 0; i < quantity; i++)
{
    var serialNumber = await GenerateTicketSerialNumberAsync(
        orderItem.TicketType.EventId, 
        ticketTypeId
    );

    var ticket = new Ticket
    {
        TicketTypeId = ticketTypeId,
        OrderItemId = orderItemId,
        SerialNumber = serialNumber,
        Status = "Assigned",
        IssuedAt = DateTime.Now
    };

    _context.Tickets.Add(ticket);
}
```

**SQL Query (Generated by EF Core):**
```sql
-- Get OrderItem details
SELECT [o].[OrderItemId], [o].[OrderId], [o].[TicketTypeId], [o].[Quantity], 
       [o].[SeatNo], [o].[Status],
       [o0].[OrderId], [o0].[CustomerId], [o0].[Amount], [o0].[Status], 
       [o0].[PaymentMethod], [o0].[CreatedAt], [o0].[UpdatedAt],
       [t].[TicketTypeId], [t].[EventId], [t].[TypeName], [t].[Price], 
       [t].[Quantity], [t].[MinOrder], [t].[MaxOrder], [t].[SaleStart], 
       [t].[SaleEnd], [t].[Status],
       [e].[EventId], [e].[HostId], [e].[Title], [e].[Description], 
       [e].[StartTime], [e].[EndTime], [e].[Location], [e].[Category], 
       [e].[Status] AS [EventStatus], [e].[CreatedAt], [e].[UpdatedAt]
FROM [OrderItems] AS [o]
INNER JOIN [Orders] AS [o0] ON [o].[OrderId] = [o0].[OrderId]
INNER JOIN [TicketTypes] AS [t] ON [o].[TicketTypeId] = [t].[TicketTypeId]
INNER JOIN [Events] AS [e] ON [t].[EventId] = [e].[EventId]
WHERE [o].[OrderItemId] = @orderItemId

-- Insert Tickets
INSERT INTO [Tickets] ([TicketTypeId], [OrderItemId], [SerialNumber], [Status], [IssuedAt])
VALUES (@ticketTypeId, @orderItemId, @serialNumber, N'Assigned', @issuedAt)
```

### 4.3 GenerateTicketSerialNumberAsync
**LINQ Query (C#):**
```csharp
var eventData = await _context.Events.FindAsync(eventId);
var ticketType = await _context.TicketTypes.FindAsync(ticketTypeId);

var timestamp = DateTime.Now.ToString("yyyyMMddHHmmss");
var random = new Random().Next(1000, 9999);
var serialNumber = $"EVENT{eventId}-TYPE{ticketTypeId}-{timestamp}-{random}";

// Ensure uniqueness
while (await _context.Tickets.AnyAsync(t => t.SerialNumber == serialNumber))
{
    random = new Random().Next(1000, 9999);
    serialNumber = $"EVENT{eventId}-TYPE{ticketTypeId}-{timestamp}-{random}";
}
```

**SQL Query (Generated by EF Core):**
```sql
-- Check if serial number exists
SELECT COUNT(*)
FROM [Tickets] AS [t]
WHERE [t].[SerialNumber] = @serialNumber
```

## 5. INVENTORY MANAGEMENT - Quản lý kho vé

### 5.1 GetTicketTypeInventoryAsync
**LINQ Query (C#):**
```csharp
var ticketType = await _context.TicketTypes
    .FirstOrDefaultAsync(tt => tt.TicketTypeId == ticketTypeId);

var soldQuantity = await _context.OrderItems
    .Where(oi => oi.TicketTypeId == ticketTypeId)
    .Where(oi => oi.Order.Status == "Paid")
    .SumAsync(oi => oi.Quantity);

var reservedQuantity = await _context.OrderItems
    .Where(oi => oi.TicketTypeId == ticketTypeId)
    .Where(oi => oi.Order.Status == "Pending")
    .SumAsync(oi => oi.Quantity);

var availableQuantity = ticketType.Quantity - soldQuantity - reservedQuantity;
```

**SQL Query (Generated by EF Core):**
```sql
-- Get ticket type info
SELECT [t].[TicketTypeId], [t].[Quantity]
FROM [TicketTypes] AS [t]
WHERE [t].[TicketTypeId] = @ticketTypeId

-- Get sold quantity
SELECT COALESCE(SUM([o].[Quantity]), 0)
FROM [OrderItems] AS [o]
INNER JOIN [Orders] AS [o0] ON [o].[OrderId] = [o0].[OrderId]
WHERE ([o].[TicketTypeId] = @ticketTypeId) AND ([o0].[Status] = N'Paid')

-- Get reserved quantity
SELECT COALESCE(SUM([o].[Quantity]), 0)
FROM [OrderItems] AS [o]
INNER JOIN [Orders] AS [o0] ON [o].[OrderId] = [o0].[OrderId]
WHERE ([o].[TicketTypeId] = @ticketTypeId) AND ([o0].[Status] = N'Pending')
```

### 5.2 GetTicketsByUserIdAsync
**LINQ Query (C#):**
```csharp
return await _context.Tickets
    .Include(t => t.TicketType)
        .ThenInclude(tt => tt.Event)
    .Include(t => t.OrderItem)
        .ThenInclude(oi => oi.Order)
    .Where(t => t.OrderItem.Order.CustomerId == userId)
    .OrderByDescending(t => t.IssuedAt)
    .ToListAsync();
```

**SQL Query (Generated by EF Core):**
```sql
SELECT [t].[TicketId], [t].[TicketTypeId], [t].[OrderItemId], [t].[SerialNumber], 
       [t].[Status], [t].[IssuedAt], [t].[UsedAt], [t].[RefundedAt],
       [t0].[TicketTypeId], [t0].[EventId], [t0].[TypeName], [t0].[Price], 
       [t0].[Quantity], [t0].[MinOrder], [t0].[MaxOrder], [t0].[SaleStart], 
       [t0].[SaleEnd], [t0].[Status],
       [e].[EventId], [e].[HostId], [e].[Title], [e].[Description], 
       [e].[StartTime], [e].[EndTime], [e].[Location], [e].[Category], 
       [e].[Status] AS [EventStatus], [e].[CreatedAt], [e].[UpdatedAt],
       [o].[OrderItemId], [o].[OrderId], [o].[TicketTypeId], [o].[Quantity], 
       [o].[SeatNo], [o].[Status],
       [o0].[OrderId], [o0].[CustomerId], [o0].[Amount], [o0].[Status], 
       [o0].[PaymentMethod], [o0].[CreatedAt], [o0].[UpdatedAt]
FROM [Tickets] AS [t]
INNER JOIN [TicketTypes] AS [t0] ON [t].[TicketTypeId] = [t0].[TicketTypeId]
INNER JOIN [Events] AS [e] ON [t0].[EventId] = [e].[EventId]
INNER JOIN [OrderItems] AS [o] ON [t].[OrderItemId] = [o].[OrderItemId]
INNER JOIN [Orders] AS [o0] ON [o].[OrderId] = [o0].[OrderId]
WHERE [o0].[CustomerId] = @userId
ORDER BY [t].[IssuedAt] DESC
```

## 6. ORDER MANAGEMENT - Quản lý đơn hàng

### 6.1 GetUserOrdersAsync
**LINQ Query (C#):**
```csharp
return await _context.Orders
    .Include(o => o.Customer)
    .Include(o => o.OrderItems)
        .ThenInclude(oi => oi.TicketType)
    .Where(o => o.CustomerId == userId)
    .OrderByDescending(o => o.CreatedAt)
    .ToListAsync();
```

**SQL Query (Generated by EF Core):**
```sql
SELECT [o].[OrderId], [o].[CustomerId], [o].[Amount], [o].[Status], 
       [o].[PaymentMethod], [o].[CreatedAt], [o].[UpdatedAt],
       [u].[UserId], [u].[Username], [u].[FullName], [u].[Email], 
       [u].[PasswordHash], [u].[Phone], [u].[Role], [u].[WalletBalance], 
       [u].[CreatedAt], [u].[UpdatedAt], [u].[Avatar], [u].[DateOfBirth], [u].[Gender],
       [o0].[OrderItemId], [o0].[OrderId], [o0].[TicketTypeId], [o0].[Quantity], 
       [o0].[SeatNo], [o0].[Status],
       [t].[TicketTypeId], [t].[EventId], [t].[TypeName], [t].[Price], 
       [t].[Quantity], [t].[MinOrder], [t].[MaxOrder], [t].[SaleStart], 
       [t].[SaleEnd], [t].[Status]
FROM [Orders] AS [o]
INNER JOIN [Users] AS [u] ON [o].[CustomerId] = [u].[UserId]
LEFT JOIN [OrderItems] AS [o0] ON [o].[OrderId] = [o0].[OrderId]
LEFT JOIN [TicketTypes] AS [t] ON [o0].[TicketTypeId] = [t].[TicketTypeId]
WHERE [o].[CustomerId] = @userId
ORDER BY [o].[CreatedAt] DESC
```

### 6.2 GetExpiredOrdersAsync
**LINQ Query (C#):**
```csharp
var expiredTime = DateTime.Now.AddMinutes(-15);
var expiredOrders = await _context.Orders
    .Where(o => o.Status == "Pending" && o.CreatedAt < expiredTime)
    .ToListAsync();
```

**SQL Query (Generated by EF Core):**
```sql
SELECT [o].[OrderId], [o].[CustomerId], [o].[Amount], [o].[Status], 
       [o].[PaymentMethod], [o].[CreatedAt], [o].[UpdatedAt]
FROM [Orders] AS [o]
WHERE ([o].[Status] = N'Pending') AND ([o].[CreatedAt] < @expiredTime)
```

### 6.3 CleanupExpiredOrdersAsync
**LINQ Query (C#):**
```csharp
var expiredOrders = await GetExpiredOrdersAsync();
var cleanedCount = 0;

foreach (var order in expiredOrders)
{
    var result = await UpdateOrderStatusAsync(order.OrderId, "Cancelled");
    if (result) cleanedCount++;
}
```

**SQL Query (Generated by EF Core):**
```sql
-- Update expired orders to Cancelled
UPDATE [Orders] 
SET [Status] = N'Cancelled', [UpdatedAt] = @updatedAt
WHERE ([Status] = N'Pending') AND ([CreatedAt] < @expiredTime)
```

## 7. WALLET TRANSACTIONS - Giao dịch ví

### 7.1 GetUserTransactionsAsync
**LINQ Query (C#):**
```csharp
return await _context.WalletTransactions
    .Where(wt => wt.UserId == userId)
    .OrderByDescending(wt => wt.CreatedAt)
    .Skip((page - 1) * pageSize)
    .Take(pageSize)
    .ToListAsync();
```

**SQL Query (Generated by EF Core):**
```sql
SELECT [w].[TransactionId], [w].[UserId], [w].[TransactionType], [w].[Amount], 
       [w].[Status], [w].[Description], [w].[ReferenceId], [w].[CreatedAt], 
       [w].[CompletedAt], [w].[BalanceBefore], [w].[BalanceAfter]
FROM [WalletTransactions] AS [w]
WHERE [w].[UserId] = @userId
ORDER BY [w].[CreatedAt] DESC
OFFSET @offset ROWS FETCH NEXT @pageSize ROWS ONLY
```

### 7.2 GetWalletBalanceAsync
**LINQ Query (C#):**
```csharp
var user = await _userRepository.GetUserByIdAsync(userId);
return user?.WalletBalance ?? 0;
```

**SQL Query (Generated by EF Core):**
```sql
SELECT [u].[WalletBalance]
FROM [Users] AS [u]
WHERE [u].[UserId] = @userId
```

## 8. TICKET VALIDATION - Kiểm tra vé

### 8.1 IsTicketValidAsync
**LINQ Query (C#):**
```csharp
var ticket = await _context.Tickets
    .Include(t => t.TicketType)
        .ThenInclude(tt => tt.Event)
    .FirstOrDefaultAsync(t => t.TicketId == ticketId);

if (ticket == null || ticket.Status != "Assigned")
    return false;

var now = DateTime.Now;
return now >= ticket.TicketType.Event.StartTime && 
       now <= ticket.TicketType.Event.EndTime;
```

**SQL Query (Generated by EF Core):**
```sql
SELECT [t].[TicketId], [t].[TicketTypeId], [t].[OrderItemId], [t].[SerialNumber], 
       [t].[Status], [t].[IssuedAt], [t].[UsedAt], [t].[RefundedAt],
       [t0].[TicketTypeId], [t0].[EventId], [t0].[TypeName], [t0].[Price], 
       [t0].[Quantity], [t0].[MinOrder], [t0].[MaxOrder], [t0].[SaleStart], 
       [t0].[SaleEnd], [t0].[Status],
       [e].[EventId], [e].[HostId], [e].[Title], [e].[Description], 
       [e].[StartTime], [e].[EndTime], [e].[Location], [e].[Category], 
       [e].[Status] AS [EventStatus], [e].[CreatedAt], [e].[UpdatedAt]
FROM [Tickets] AS [t]
INNER JOIN [TicketTypes] AS [t0] ON [t].[TicketTypeId] = [t0].[TicketTypeId]
INNER JOIN [Events] AS [e] ON [t0].[EventId] = [e].[EventId]
WHERE [t].[TicketId] = @ticketId
```

### 8.2 CheckInTicketAsync
**LINQ Query (C#):**
```csharp
var ticket = await _context.Tickets
    .Include(t => t.TicketType)
        .ThenInclude(tt => tt.Event)
    .FirstOrDefaultAsync(t => t.TicketId == ticketId);

ticket.Status = "Used";
ticket.UsedAt = DateTime.Now;
await _context.SaveChangesAsync();
```

**SQL Query (Generated by EF Core):**
```sql
UPDATE [Tickets] 
SET [Status] = N'Used', [UsedAt] = @usedAt
WHERE [TicketId] = @ticketId
```

## 9. BUSINESS RULES VALIDATION - Kiểm tra quy tắc nghiệp vụ

### 9.1 Validate Sale Period
**LINQ Query (C#):**
```csharp
var now = DateTime.Now;
if (now < ticketType.SaleStart)
    throw new ArgumentException($"Ticket sales have not started yet. Sales start at: {ticketType.SaleStart:yyyy-MM-dd HH:mm}");

if (now > ticketType.SaleEnd)
    throw new ArgumentException($"Ticket sales have ended. Sales ended at: {ticketType.SaleEnd:yyyy-MM-dd HH:mm}");
```

**SQL Query (Generated by EF Core):**
```sql
SELECT [t].[TicketTypeId], [t].[SaleStart], [t].[SaleEnd], [t].[Status]
FROM [TicketTypes] AS [t]
WHERE [t].[TicketTypeId] = @ticketTypeId
```

### 9.2 Validate MinOrder/MaxOrder
**LINQ Query (C#):**
```csharp
if (ticketType.MinOrder.HasValue && request.Quantity < ticketType.MinOrder.Value)
    throw new ArgumentException($"Minimum order quantity is {ticketType.MinOrder.Value}");

if (ticketType.MaxOrder.HasValue && request.Quantity > ticketType.MaxOrder.Value)
    throw new ArgumentException($"Maximum order quantity is {ticketType.MaxOrder.Value}");
```

**SQL Query (Generated by EF Core):**
```sql
SELECT [t].[TicketTypeId], [t].[MinOrder], [t].[MaxOrder], [t].[Quantity]
FROM [TicketTypes] AS [t]
WHERE [t].[TicketTypeId] = @ticketTypeId
```

## 10. ERROR HANDLING - Xử lý lỗi

### 10.1 Database Transaction Rollback
**LINQ Query (C#):**
```csharp
using var transaction = await _context.Database.BeginTransactionAsync();
try
{
    // Perform operations
    await _context.SaveChangesAsync();
    await transaction.CommitAsync();
}
catch (Exception ex)
{
    await transaction.RollbackAsync();
    throw new Exception($"Error in operation: {ex.Message}", ex);
}
```

**SQL Query (Generated by EF Core):**
```sql
-- Transaction is handled at application level
-- EF Core automatically generates BEGIN TRANSACTION, COMMIT, ROLLBACK
```

## GHI CHÚ QUAN TRỌNG:

1. **Transaction Safety**: Tất cả operations đều được wrap trong database transaction
2. **Concurrent Access**: Sử dụng appropriate locking để tránh race conditions  
3. **Data Validation**: Kiểm tra tất cả business rules trước khi thực hiện operations
4. **Error Handling**: Có rollback mechanism khi có lỗi xảy ra
5. **Performance**: Sử dụng indexes phù hợp cho các queries thường xuyên
6. **Security**: Validate input parameters để tránh SQL injection
7. **Audit Trail**: Ghi lại tất cả changes quan trọng
8. **Inventory Consistency**: Đảm bảo số lượng vé luôn chính xác
9. **Time Validation**: Kiểm tra thời gian bán vé và thời gian sự kiện
10. **Authorization**: Kiểm tra quyền truy cập ở mọi operations

## CÁC INDEXES ĐƯỢC KHUYẾN NGHỊ:

```sql
-- Indexes cho performance
CREATE INDEX IX_Orders_CustomerId_Status ON Orders(CustomerId, Status);
CREATE INDEX IX_Orders_CreatedAt_Status ON Orders(CreatedAt, Status);
CREATE INDEX IX_OrderItems_TicketTypeId ON OrderItems(TicketTypeId);
CREATE INDEX IX_Tickets_SerialNumber ON Tickets(SerialNumber);
CREATE INDEX IX_Tickets_OrderItemId ON Tickets(OrderItemId);
CREATE INDEX IX_WalletTransactions_UserId_CreatedAt ON WalletTransactions(UserId, CreatedAt);
CREATE INDEX IX_TicketTypes_EventId_Status ON TicketTypes(EventId, Status);
CREATE INDEX IX_Events_Status_StartTime ON Events(Status, StartTime);
```
